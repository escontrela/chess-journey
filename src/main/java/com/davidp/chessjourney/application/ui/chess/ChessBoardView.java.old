package com.davidp.chessjourney.application.ui.chess;

import static com.chess.application.ui.sound.PlaySoundService.Sound.*;
import static com.chess.application.ui.util.PositionTranslateService.toChessBoardPosition;
import static com.chess.application.ui.util.PositionTranslateService.toSquareViewPosition;

import com.chess.application.ui.sound.PlaySoundService;
import com.chess.application.ui.util.PositionTranslateService;
import com.chess.application.ui.util.ThemeProperties;
import com.chess.application.ui.util.ThemeService;
import com.chess.application.util.SpringContext;
import com.chess.model.*;
import java.util.*;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.control.Label;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.util.Pair;

/**
 * Resources:
 * - online converter: https://www.online-convert.com/es
 * - sound resources: https://freesound.org/
 * - https://www.baeldung.com/spring-events
 * <p>
 * Resize picture:
 * https://images.chesscomfiles.com/chess-themes/pieces/club/82/wp.png
 */
public class ChessBoardView {

    private Group chessBoard;

    private Label labelResult;

    private String theme;
    public ArrayList<SquareView> squareViews = new ArrayList<>();
    private Game currentGame;
    private Optional<Position> lastSelectedPosition = Optional.empty();
    private Set<Move> currentSelectedPossibleMoves = Collections.emptySet();
    protected PlaySoundService soundService = SpringContext.getBean(PlaySoundService.class);
    protected ThemeService themeService = SpringContext.getBean(ThemeService.class);
    protected ThemeProperties selectedTheme;

    public ChessBoardView(final Group chessBoard, final String theme, final Label labelResult) {

        this.chessBoard = chessBoard;
        this.labelResult = labelResult;
        this.theme = theme;
        selectedTheme = themeService.getThemeCharacteristics(theme);

        buildChessboardView(this.chessBoard, theme);
        addChessBoardViewEventHandlers(chessBoard);
    }


    public void startNewGame(final Game game) {

        Objects.requireNonNull(game);

        currentGame = game;
        soundService.play(BOARD_START);
        initGameStatus(game);
    }

    private void initGameStatus(final Game game) {

        this.cleanChessboardView();

        squareViews.forEach(square -> {

            Position squarePosition = toChessBoardPosition(square.x, square.y);

            Optional<Piece> pieceFromPosition = game.getChessboard().getPieceFromPosition(squarePosition);
            pieceFromPosition
                    .ifPresent(piece -> addPieceFromPosition(square, piece, squarePosition));
        });
    }

    public void cleanChessboardView() {

        squareViews.forEach(e -> {
            if (e.getChildren().size() > 0) {

                freeSquare(e);
            }
        });
    }

    private void buildChessboardView(final Group chessBoardControl, final String theme) {

        final int with = 100;
        final int height = 100;

        for (int i = 0; i < 8; i++) {

            for (int j = 0; j < 8; j++) {

                SquareView squareView = new SquareView(i, j);
                squareViews.add(squareView);

                squareView.setName("Square" + i + j);
                squareView.setLayoutX(i * with);
                squareView.setLayoutY(j * height);
                squareView.setPrefHeight(with);
                squareView.setPrefWidth(height);
                squareView.setBorder(new Border(new BorderStroke(Color.BLACK,
                        BorderStrokeStyle.SOLID,
                        CornerRadii.EMPTY,
                        BorderWidths.DEFAULT)));
                squareView.setBackground(selectedTheme.getBlackSquaresColor(), selectedTheme.getWhiteSquaresColor());
                chessBoardControl.getChildren().add(squareView);

                squareView.setOnDragOver(event -> {

                    event.acceptTransferModes(TransferMode.ANY);
                    event.consume();
                });

                squareView.setOnDragDropped(getDragDropManager(squareView));
            }
        }
    }

    /**
     * Add a piece to the chessboard view position.
     */
    private void addPieceFromPosition(final SquareView e, final Piece piece, final Position pos) {

        PieceView pieceView = PieceViewFactory.getPiece(piece.getKind(),
                piece.getColor(), pos);

        addPiece(e, pieceView);
    }


    private void addChessBoardViewEventHandlers(final Group chessBoard) {

        chessBoard.setOnMousePressed(event -> {

            Optional<SquareView> selectedSquare = getSquareViewFromMouseEvent(event);

            if (selectedSquare.isPresent()) {

                Position selectedPosition = toChessBoardPosition(selectedSquare.get().x, selectedSquare.get().y);

                undoLastSelection();

                if (isTheSamePositionThatLastPosition(selectedPosition)) {

                    return;
                }

                if (!isThereAnyPieceOn(selectedPosition)) {

                    return;
                }

                /** //TODO uncomment for game turns!!
                 if (currentGame.hasPlayers() &&
                 !currentGame.isTurnFor(pieceFromPosition.get().getColor())) {

                 return;
                 }
                 */

                selectPiece(selectedSquare.get());

                Map<Position,Set<Piece>> attacked = this.currentGame.getChessRules().atackedPositions(Piece.Color.WHITE);
                attacked.forEach((k,v) -> System.out.println("The position " + k + " is attacked by the pieces:  " + v));
            }
        });
    }

    private boolean isTheSamePositionThatLastPosition(final Position selectedPosition) {

        return (lastSelectedPosition.isPresent() && selectedPosition.equals(lastSelectedPosition.get()));
    }


    private boolean isThereAnyPieceOn(final Position selectedPosition) {

        Optional<Piece> pieceFromPosition =
                currentGame.getChessboard().getPieceFromPosition(selectedPosition);

        return pieceFromPosition.isPresent();
    }

    private Optional<SquareView> getSquareViewFromMouseEvent(MouseEvent event) {

        Optional<SquareView> isSquare = Optional.ofNullable(event.getTarget()).filter(t -> t.toString().equals("Square")).map
                (t -> (SquareView) t).or(() ->
                Optional.ofNullable(event.getTarget()).map(t -> (PieceView) t).map(t -> (SquareView) t.getParent()));

        return isSquare;
    }

    private void undoLastSelection() {

        if (lastSelectedPosition.isPresent()) {

            for (SquareView squareView : squareViews) {

                Position squarePosition = toChessBoardPosition(squareView.x, squareView.y);

                if (currentSelectedPossibleMoves.contains(squarePosition)) {

                    unSetSelectedBackGround(squareView);
                }
            }

            currentSelectedPossibleMoves = Collections.emptySet();
            lastSelectedPosition = Optional.empty();
        }

    }

    private void selectPiece(final SquareView selectedSquare) {

        Position selectedPosition = toChessBoardPosition(selectedSquare.x, selectedSquare.y);

        this.lastSelectedPosition = Optional.of(selectedPosition);
        this.currentSelectedPossibleMoves = new HashSet<>();
        this.currentSelectedPossibleMoves.add(new Move(selectedPosition, Move.MoveType.POSITION));

        Optional<Piece> pieceFromPosition = currentGame.getChessboard().getPieceFromPosition(selectedPosition);

        if (pieceFromPosition.isEmpty()) {

            return;
        }

        Piece selectedPiece = pieceFromPosition.get();

        Set<Move> allowedMoves = currentGame.getChessRules().allowedMoves(selectedPiece);
        this.currentSelectedPossibleMoves.addAll(allowedMoves);

        setSelectedBackGround(selectedSquare);

        for (SquareView squareView : squareViews) {

            Position squarePosition = toChessBoardPosition(squareView.x, squareView.y);
            if (allowedMoves.contains(squarePosition)) {

                //TODO Refactor this method!
                Optional<Move> moveStream = allowedMoves.stream().filter(e -> e.equals(squarePosition)).findFirst();

                if (moveStream.isPresent()) {

                    Move realMove = moveStream.get();
                    if (realMove.getMoveType() == Move.MoveType.EAT) {
                        setSelectedBackGroundForEat(squareView);
                    } else {
                        setSelectedBackGround(squareView);
                    }
                }
            }
        }
    }

    private void setSelectedBackGround(final SquareView square) {

        Color color1 = Color.web("#e4c16f");
        square.setBackground(new Background(new BackgroundFill(color1, CornerRadii.EMPTY, Insets.EMPTY)));
    }

    private void setSelectedBackGroundForEat(final SquareView square) {

        Color color1 = Color.web("#e6709d");
        square.setBackground(new Background(new BackgroundFill(color1, CornerRadii.EMPTY, Insets.EMPTY)));
    }

    private void setSelectedCheckBackGround(final SquareView square) {

        Color color1 = Color.web("#802d2d");
        square.setBackground(new Background(new BackgroundFill(color1, CornerRadii.EMPTY, Insets.EMPTY)));
    }

    private void unSetSelectedBackGround(final SquareView square) {

        square.setBackground(selectedTheme.getBlackSquaresColor(), selectedTheme.getWhiteSquaresColor());
    }


    /*
     * Move a piece with drag and drop
     */
    private EventHandler<? super DragEvent> getDragDropManager(final SquareView toSquare) {

        return (DragEvent event) -> {

            PieceView fromPiece = (PieceView) event.getGestureSource();
            SquareView fromSquare = (SquareView) fromPiece.getParent();

            Position sourcePosition = toChessBoardPosition(fromSquare.x, fromSquare.y);
            Position destinationPosition = toChessBoardPosition(toSquare.x, toSquare.y);

            Optional<Piece> pieceFromPosition = currentGame.getChessboard().getPieceFromPosition(sourcePosition);
            if (pieceFromPosition.isEmpty()) {

                soundService.play(MOVE_ERR);
                event.consume();
                return;
            }

            Set<Move> allowedPositions = currentGame.getChessRules().allowedMoves(pieceFromPosition.get());

            if (!allowedPositions.contains(destinationPosition)) {

                soundService.play(MOVE_ERR);
                event.consume();
                return;
            }


            freeSquare(fromSquare);
            addPieceFromPosition(toSquare, pieceFromPosition.get(), destinationPosition);
            currentGame.getChessboard().move(pieceFromPosition.get(), destinationPosition);

            if (isAnEatMove(destinationPosition, allowedPositions)) {

                soundService.play(EAT_PIECE);

            } else {

                soundService.play(PIECE_PLACEMENT);
            }

            undoLastSelection();

            //TODO Refactor all this code!

            Optional<Piece> theKing = currentGame.getChessboard().getPiece(pieceFromPosition.get().getColor() == Piece.Color.WHITE ? Piece.Color.BLACK : Piece.Color.WHITE, Piece.Kind.KING);

            if (theKing.isPresent()) {

                boolean isInCheck = currentGame.getChessRules()
                        .isCheck(theKing.get(), currentGame.getChessboard());

                System.out.println("The " + theKing.get().getColor() + " is in check: " + isInCheck);

                if (isInCheck) {

                    final Position position = currentGame.getChessboard().isPiece(theKing.get()).get();


                    final Pair<Integer, Integer> integerIntegerPair = toSquareViewPosition(position);

                    for (SquareView squareView : squareViews) {

                        if (squareView.x == integerIntegerPair.getKey() && squareView.y == integerIntegerPair.getValue()) {

                            setSelectedCheckBackGround(squareView);
                            labelResult.setText("Check for the " + pieceFromPosition.get().getColor() + " pieces.");
                        }
                    }

                    soundService.play(MOVE_ERR);
                }
            }

            if (currentGame.getChessRules().isCheckMate(pieceFromPosition.get().getColor().getOpposite())) {

                labelResult.setText("CHECK MATE for the " + pieceFromPosition.get().getColor() + " pieces. " + pieceFromPosition.get().getColor() + "s WON the game!.");
            }

            event.consume();
        };
    }

    private boolean isAnEatMove(Position destinationPosition, Set<Move> allowedPositions) {

        Optional<Move> first = allowedPositions.stream().filter(m -> m.equals(destinationPosition)).findFirst();

        return first.isPresent() && first.get().getMoveType() == Move.MoveType.EAT;
    }

    private void freeSquare(SquareView fromSquare) {

        if (!fromSquare.getChildren().isEmpty()) {

            fromSquare.getChildren().remove(0);
        }

        fromSquare.occupied = false;
    }

    private void addPiece(final SquareView squareView, final PieceView piece) {

        freeSquare(squareView);
        squareView.getChildren().add(piece);
        squareView.occupied = true;

        piece.setOnDragDetected((MouseEvent event) -> {

            Position position = PositionTranslateService.toChessBoardPosition(squareView.x, squareView.y);

            Dragboard db = piece.startDragAndDrop(TransferMode.ANY);

            Map<DataFormat, Object> var1 = new HashMap<>();
            var1.put(DataFormat.IMAGE, position);

            db.setContent(var1);
            event.consume();
        });
    }
}
